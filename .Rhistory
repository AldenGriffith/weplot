#
library(ggplot2)
#sliders
#-number of species  DONE
#-homogeneity vs. heterogeneity
#-number of sampling plots
#-evenness vs. dominance  DONE
#-noise?
#-total individuals  DONE
#get numbers of each species ----
S <- 24
n <- 590
eve.dom <- 5 #max = 100?
beta <- 5
# eve.dom <- eve.dom^(1/10)  #can mediate how quickly dominance comes in. high denominator will inhibit dominance
species.n <- exp(-eve.dom * seq(0, 1, length.out = S))
species.n <- ceiling((species.n / sum(species.n)) * n)
#remove extras
cut <- sum(species.n) - n
if (cut > 0){
i <- which(species.n > 1)
cut.frac <- species.n[i] / sum(species.n[i])
cut.n <- round(cut.frac * cut)
while (sum(cut.n) < cut) cut.n[1] <- cut.n[1] + 1
while (sum(cut.n) > cut) cut.n[1] <- cut.n[1] - 1
species.n[i] <- species.n[i] - cut.n[i]
}
species.n <- sort(species.n, decreasing = TRUE)
plot(species.n, main = sum(species.n), ylim = c(0, max(species.n)))
abline(h = 0)
#BY Species----
#make random points
#make centroids
#calculate distance of points to centroids?
X <- runif(n)
Y <- runif(n)
cen.x <- runif(S)
cen.y <- runif(S)
plot(X,Y)
points(cen.x, cen.y, col = "red", pch = "+")
#calculates distances to a reference point
RefDist <- function(Xref, Yref, X, Y) sqrt((Xref - X)^2 + (Yref - Y)^2)
# RefDist(X[1],Y[1], cen.x, cen.y)
#vector for allocated species
Species <- numeric(n)
#set of individuals to sample
pool <- 1:n
#randomize species order? (or maybe should go in abundance order?)
for (s in sample(1:S,S)){
# for (s in rev(1:S)){
#calculate distance of all points to species reference (for weighting)
d <- RefDist(cen.x[s], cen.y[s], X[pool], Y[pool])
#sample individuals with distance weighting scaled using heterogeneity factor
i <- sample(pool, species.n[s], prob = (max(d) - d)^beta)
#remove individuals already allocated
pool <- pool[!is.element(pool,i)]
Species[i] <- s
}
C <- data.frame(Species  = Species,
X = X,
Y = Y)
ggplot(C, aes(X, Y)) +
geom_point(aes(color = Species)) +
scale_color_gradientn(colours = rainbow(100)[-(1:10)])
# #OLD spatial distribution----
#
# #hmmmm..... I'd rather create runif points and then decide which species it should be...
#
# beta <- 1  #heterogeneity   #scale needs to account for S and N; fill the space!
#
# #use beta distribution!
# # hist(rbeta(1000, 1, 1), xlim = c(0,1))  #uniform
# # hist(rbeta(1000, 1, 100), xlim = c(0,1))  #highly clumped
#
#
# cen.x <- runif(S)
# cen.y <- runif(S)
#
# C <- data.frame(Species = rep(1:S, species.n),
#                 cen.x = rep(cen.x, species.n),
#                 cen.y = rep(cen.y, species.n))
#
# off.x <- rbeta(n, 1, beta) * sample(c(-1, 1), n, replace = TRUE)
# off.y <- rbeta(n, 1, beta) * sample(c(-1, 1), n, replace = TRUE)
#
# C$x <- C$cen.x + off.x
# C$y <- C$cen.y + off.y
#
# #wrap around
# C$x[C$x < 0] <- 1 + C$x[C$x < 0]
# C$x[C$x > 1] <- C$x[C$x > 1] - 1
#
# C$y[C$y < 0] <- 1 + C$y[C$y < 0]
# C$y[C$y > 1] <- C$y[C$y > 1] - 1
#
#
# ggplot(C, aes(x, y)) +
#   geom_point(aes(color = Species)) +
#   scale_color_gradientn(colours = rainbow(S)) +
#   geom_hline(yintercept = c(0,1)) +
#   geom_vline(xintercept = c(0,1)) +
#   geom_point(aes(cen.x, cen.y), shape = "+", size = 3)
#
source('~/Shiny/biodiversity/biodiversity test.R', echo=TRUE)
s
library(ggplot2)
#sliders
#-number of species  DONE
#-homogeneity vs. heterogeneity
#-number of sampling plots
#-evenness vs. dominance  DONE
#-noise?
#-total individuals  DONE
#get numbers of each species ----
S <- 24
n <- 590
eve.dom <- 5 #max = 100?
beta <- 5
# eve.dom <- eve.dom^(1/10)  #can mediate how quickly dominance comes in. high denominator will inhibit dominance
species.n <- exp(-eve.dom * seq(0, 1, length.out = S))
species.n <- ceiling((species.n / sum(species.n)) * n)
#remove extras
cut <- sum(species.n) - n
if (cut > 0){
i <- which(species.n > 1)
cut.frac <- species.n[i] / sum(species.n[i])
cut.n <- round(cut.frac * cut)
while (sum(cut.n) < cut) cut.n[1] <- cut.n[1] + 1
while (sum(cut.n) > cut) cut.n[1] <- cut.n[1] - 1
species.n[i] <- species.n[i] - cut.n[i]
}
species.n <- sort(species.n, decreasing = TRUE)
plot(species.n, main = sum(species.n), ylim = c(0, max(species.n)))
abline(h = 0)
#BY Species----
#make random points
#make centroids
#calculate distance of points to centroids?
X <- runif(n)
Y <- runif(n)
cen.x <- runif(S)
cen.y <- runif(S)
plot(X,Y)
points(cen.x, cen.y, col = "red", pch = "+")
#calculates distances to a reference point
RefDist <- function(Xref, Yref, X, Y) sqrt((Xref - X)^2 + (Yref - Y)^2)
# RefDist(X[1],Y[1], cen.x, cen.y)
#vector for allocated species
Species <- numeric(n)
#set of individuals to sample
pool <- 1:n
S.Order <- sample(1:S,S)
#randomize species order? (or maybe should go in abundance order?)
for (s in S.Order){
# for (s in rev(1:S)){
#calculate distance of all points to species reference (for weighting)
d <- RefDist(cen.x[s], cen.y[s], X[pool], Y[pool])
#sample individuals with distance weighting scaled using heterogeneity factor
i <- sample(pool, species.n[s], prob = (max(d) - d)^beta)
#remove individuals already allocated
pool <- pool[!is.element(pool,i)]
Species[i] <- s
}
C <- data.frame(Species  = Species,
X = X,
Y = Y)
ggplot(C, aes(X, Y)) +
geom_point(aes(color = Species)) +
scale_color_gradientn(colours = rainbow(100)[-(1:10)])
# #OLD spatial distribution----
#
# #hmmmm..... I'd rather create runif points and then decide which species it should be...
#
# beta <- 1  #heterogeneity   #scale needs to account for S and N; fill the space!
#
# #use beta distribution!
# # hist(rbeta(1000, 1, 1), xlim = c(0,1))  #uniform
# # hist(rbeta(1000, 1, 100), xlim = c(0,1))  #highly clumped
#
#
# cen.x <- runif(S)
# cen.y <- runif(S)
#
# C <- data.frame(Species = rep(1:S, species.n),
#                 cen.x = rep(cen.x, species.n),
#                 cen.y = rep(cen.y, species.n))
#
# off.x <- rbeta(n, 1, beta) * sample(c(-1, 1), n, replace = TRUE)
# off.y <- rbeta(n, 1, beta) * sample(c(-1, 1), n, replace = TRUE)
#
# C$x <- C$cen.x + off.x
# C$y <- C$cen.y + off.y
#
# #wrap around
# C$x[C$x < 0] <- 1 + C$x[C$x < 0]
# C$x[C$x > 1] <- C$x[C$x > 1] - 1
#
# C$y[C$y < 0] <- 1 + C$y[C$y < 0]
# C$y[C$y > 1] <- C$y[C$y > 1] - 1
#
#
# ggplot(C, aes(x, y)) +
#   geom_point(aes(color = Species)) +
#   scale_color_gradientn(colours = rainbow(S)) +
#   geom_hline(yintercept = c(0,1)) +
#   geom_vline(xintercept = c(0,1)) +
#   geom_point(aes(cen.x, cen.y), shape = "+", size = 3)
#
S.Order
s
pool
#calculate distance of all points to species reference (for weighting)
d <- RefDist(cen.x[s], cen.y[s], X[pool], Y[pool])
d
#sample individuals with distance weighting scaled using heterogeneity factor
i <- sample(pool, species.n[s], prob = (max(d) - d)^beta)
length(d)
length(pool)
species.n[s]
(max(d) - d)^beta)
(max(d) - d)^beta
length((max(d) - d)^beta)
#sample individuals with distance weighting scaled using heterogeneity factor
i <- sample(pool, species.n[s], prob = (max(d) - d)^beta)
length(pool)
species.n[s]
sample(1:4,4)
sample(1:4,4, prob = 1:4)
sample(pool, species.n[s], prob = (max(d) - d)^beta)
prob
(max(d) - d)^beta
beta
d
.5^20
#sample individuals with distance weighting scaled using heterogeneity factor
i <- sample(pool, species.n[s], prob = (max(d) - d + 1)^beta)
runApp('Shiny/biodiversity')
library(ggplot2)
#sliders
#-number of species  DONE
#-homogeneity vs. heterogeneity
#-number of sampling plots
#-evenness vs. dominance  DONE
#-noise?
#-total individuals  DONE
#get numbers of each species ----
S <- 24
n <- 590
eve.dom <- 39 #max = 100?
beta <- 76
# eve.dom <- eve.dom^(1/10)  #can mediate how quickly dominance comes in. high denominator will inhibit dominance
species.n <- exp(-eve.dom * seq(0, 1, length.out = S))
species.n <- ceiling((species.n / sum(species.n)) * n)
#remove extras
cut <- sum(species.n) - n
if (cut > 0){
i <- which(species.n > 1)
cut.frac <- species.n[i] / sum(species.n[i])
cut.n <- round(cut.frac * cut)
while (sum(cut.n) < cut) cut.n[1] <- cut.n[1] + 1
while (sum(cut.n) > cut) cut.n[1] <- cut.n[1] - 1
species.n[i] <- species.n[i] - cut.n[i]
}
species.n <- sort(species.n, decreasing = TRUE)
plot(species.n, main = sum(species.n), ylim = c(0, max(species.n)))
abline(h = 0)
#BY Species----
#make random points
#make centroids
#calculate distance of points to centroids?
X <- runif(n)
Y <- runif(n)
cen.x <- runif(S)
cen.y <- runif(S)
plot(X,Y)
points(cen.x, cen.y, col = "red", pch = "+")
#calculates distances to a reference point
RefDist <- function(Xref, Yref, X, Y) sqrt((Xref - X)^2 + (Yref - Y)^2)
# RefDist(X[1],Y[1], cen.x, cen.y)
#vector for allocated species
Species <- numeric(n)
#set of individuals to sample
pool <- 1:n
S.Order <- sample(1:S,S)
#randomize species order? (or maybe should go in abundance order?)
for (s in S.Order){
# for (s in rev(1:S)){
#calculate distance of all points to species reference (for weighting)
d <- RefDist(cen.x[s], cen.y[s], X[pool], Y[pool])
#sample individuals with distance weighting scaled using heterogeneity factor (+1 to make positive)
i <- sample(pool, species.n[s], prob = (max(d) - d + 1)^beta)
#remove individuals already allocated
pool <- pool[!is.element(pool,i)]
Species[i] <- s
}
C <- data.frame(Species  = Species,
X = X,
Y = Y)
ggplot(C, aes(X, Y)) +
geom_point(aes(color = Species)) +
scale_color_gradientn(colours = rainbow(100)[-(1:10)])
# #OLD spatial distribution----
#
# #hmmmm..... I'd rather create runif points and then decide which species it should be...
#
# beta <- 1  #heterogeneity   #scale needs to account for S and N; fill the space!
#
# #use beta distribution!
# # hist(rbeta(1000, 1, 1), xlim = c(0,1))  #uniform
# # hist(rbeta(1000, 1, 100), xlim = c(0,1))  #highly clumped
#
#
# cen.x <- runif(S)
# cen.y <- runif(S)
#
# C <- data.frame(Species = rep(1:S, species.n),
#                 cen.x = rep(cen.x, species.n),
#                 cen.y = rep(cen.y, species.n))
#
# off.x <- rbeta(n, 1, beta) * sample(c(-1, 1), n, replace = TRUE)
# off.y <- rbeta(n, 1, beta) * sample(c(-1, 1), n, replace = TRUE)
#
# C$x <- C$cen.x + off.x
# C$y <- C$cen.y + off.y
#
# #wrap around
# C$x[C$x < 0] <- 1 + C$x[C$x < 0]
# C$x[C$x > 1] <- C$x[C$x > 1] - 1
#
# C$y[C$y < 0] <- 1 + C$y[C$y < 0]
# C$y[C$y > 1] <- C$y[C$y > 1] - 1
#
#
# ggplot(C, aes(x, y)) +
#   geom_point(aes(color = Species)) +
#   scale_color_gradientn(colours = rainbow(S)) +
#   geom_hline(yintercept = c(0,1)) +
#   geom_vline(xintercept = c(0,1)) +
#   geom_point(aes(cen.x, cen.y), shape = "+", size = 3)
#
s
pool
species.n[s]
#sample individuals with distance weighting scaled using heterogeneity factor (+1 to make positive)
i <- sample(pool, species.n[s], prob = (max(d) - d + 1)^beta)
pool
species.n[s]
(max(d) - d + 1)^beta
sample(21, 1, prob = 1)
sample(21, 1)
sample.int(21, 1)
sample.int(21, 1)
sample.int("21", 1)
sample.int(as.matrix(21), 1)
sample.int(21, 1)
library(ggplot2)
#sliders
#-number of species  DONE
#-homogeneity vs. heterogeneity
#-number of sampling plots
#-evenness vs. dominance  DONE
#-noise?
#-total individuals  DONE
#get numbers of each species ----
S <- 24
n <- 590
eve.dom <- 39 #max = 100?
beta <- 76
# eve.dom <- eve.dom^(1/10)  #can mediate how quickly dominance comes in. high denominator will inhibit dominance
species.n <- exp(-eve.dom * seq(0, 1, length.out = S))
species.n <- ceiling((species.n / sum(species.n)) * n)
#remove extras
cut <- sum(species.n) - n
if (cut > 0){
i <- which(species.n > 1)
cut.frac <- species.n[i] / sum(species.n[i])
cut.n <- round(cut.frac * cut)
while (sum(cut.n) < cut) cut.n[1] <- cut.n[1] + 1
while (sum(cut.n) > cut) cut.n[1] <- cut.n[1] - 1
species.n[i] <- species.n[i] - cut.n[i]
}
species.n <- sort(species.n, decreasing = TRUE)
plot(species.n, main = sum(species.n), ylim = c(0, max(species.n)))
abline(h = 0)
#BY Species----
#make random points
#make centroids
#calculate distance of points to centroids?
X <- runif(n)
Y <- runif(n)
cen.x <- runif(S)
cen.y <- runif(S)
plot(X,Y)
points(cen.x, cen.y, col = "red", pch = "+")
#calculates distances to a reference point
RefDist <- function(Xref, Yref, X, Y) sqrt((Xref - X)^2 + (Yref - Y)^2)
# RefDist(X[1],Y[1], cen.x, cen.y)
#vector for allocated species
Species <- numeric(n)
#set of individuals to sample
pool <- 1:n
S.Order <- sample(1:S,S)
#randomize species order? (or maybe should go in abundance order?)
for (s in S.Order){
# for (s in rev(1:S)){
#calculate distance of all points to species reference (for weighting)
d <- RefDist(cen.x[s], cen.y[s], X[pool], Y[pool])
#sample individuals with distance weighting scaled using heterogeneity factor (+1 to make positive)
if (length(pool) == 1){
i <- pool
} else {
i <- sample(pool, species.n[s], prob = (max(d) - d + 1)^beta)
}
#remove individuals already allocated
pool <- pool[!is.element(pool,i)]
Species[i] <- s
}
C <- data.frame(Species  = Species,
X = X,
Y = Y)
ggplot(C, aes(X, Y)) +
geom_point(aes(color = Species)) +
scale_color_gradientn(colours = rainbow(100)[-(1:10)])
# #OLD spatial distribution----
#
# #hmmmm..... I'd rather create runif points and then decide which species it should be...
#
# beta <- 1  #heterogeneity   #scale needs to account for S and N; fill the space!
#
# #use beta distribution!
# # hist(rbeta(1000, 1, 1), xlim = c(0,1))  #uniform
# # hist(rbeta(1000, 1, 100), xlim = c(0,1))  #highly clumped
#
#
# cen.x <- runif(S)
# cen.y <- runif(S)
#
# C <- data.frame(Species = rep(1:S, species.n),
#                 cen.x = rep(cen.x, species.n),
#                 cen.y = rep(cen.y, species.n))
#
# off.x <- rbeta(n, 1, beta) * sample(c(-1, 1), n, replace = TRUE)
# off.y <- rbeta(n, 1, beta) * sample(c(-1, 1), n, replace = TRUE)
#
# C$x <- C$cen.x + off.x
# C$y <- C$cen.y + off.y
#
# #wrap around
# C$x[C$x < 0] <- 1 + C$x[C$x < 0]
# C$x[C$x > 1] <- C$x[C$x > 1] - 1
#
# C$y[C$y < 0] <- 1 + C$y[C$y < 0]
# C$y[C$y > 1] <- C$y[C$y > 1] - 1
#
#
# ggplot(C, aes(x, y)) +
#   geom_point(aes(color = Species)) +
#   scale_color_gradientn(colours = rainbow(S)) +
#   geom_hline(yintercept = c(0,1)) +
#   geom_vline(xintercept = c(0,1)) +
#   geom_point(aes(cen.x, cen.y), shape = "+", size = 3)
#
runApp('Shiny/biodiversity')
shiny::runApp('Shiny/biodiversity')
?DT::renderTable
runApp('Shiny/biodiversity')
runApp('Shiny/biodiversity')
?datatable
runApp('Shiny/biodiversity')
?renderDT
runApp('Shiny/biodiversity')
runApp('Shiny/biodiversity')
runApp('Shiny/biodiversity')
renderDT
?renderDT
?DT::renderDataTable
runApp('Shiny/biodiversity')
runApp('Shiny/biodiversity')
runApp('Shiny/biodiversity')
runApp('Shiny/biodiversity')
runApp('Shiny/biodiversity')
?DTOutput
runApp('Shiny/biodiversity')
runApp('Shiny/biodiversity')
runApp('Shiny/biodiversity')
runApp('Shiny/biodiversity')
runApp('Shiny/biodiversity')
runApp('Shiny/biodiversity')
runApp('Shiny/biodiversity')
runApp('Shiny/biodiversity')
runApp('Shiny/biodiversity')
runApp('Shiny/biodiversity')
runApp('Shiny/biodiversity')
runApp('Shiny/biodiversity')
runApp('Shiny/biodiversity')
runApp('Shiny/biodiversity')
runApp('Shiny/biodiversity')
runApp('Shiny/biodiversity')
load("~/Wellesley Courses/ES 220/ES 220 S22/Labs/04/Code/Lab 4 Data - Jan 6 2021.RData")
load("~/Wellesley Courses/ES 220/ES 220 S22/Labs/04/Code/Lab 4 Data - Jan 6 2021.RData")
setwd("~/GitHub/weplot")
Glacier <- read_csv("Glacier Data Stacked.csv")
Hub <- read_csv("Hubbard Brook.csv")
library(tidyverse)
load("~/Wellesley Courses/ES 220/ES 220 S22/Labs/04/Code/Lab 4 Data - Jan 6 2021.RData")
setwd("~/GitHub/weplot")
Glacier <- read_csv("Glacier Data Stacked.csv")
Hub <- read_csv("Hubbard Brook.csv")
load("~/Wellesley Courses/ES 220/ES 220 S22/Labs/04/Code/Lab 4 Data - Jan 6 2021.RData")
source('~/GitHub/weplot/weplot function dev 1.2.R', echo=TRUE)
weplot(x = Hour, y = list(Elec.Observed.W, Solar.Radiation.Wm2))
weplot(x = Hub$Date, y = list(Hub$`Precip pH`, Hub$`Stream pH`))
